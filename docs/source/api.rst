=========
API reference
=========

**smol** is organized into two main submodules:

- :ref:`smol.cofe api` (Cluster Orbit Fourier Expansion) includes classes and
  functions to define, train and test cluster expansions.
- :ref:`smol.moca api` (Monte Carlo) includes classes and functions to run MCMC
  sampling based on a cluster expansion hamiltonian (and a few other
  hamiltonian models).

Below is the documentation for the core classes in each submodule.
You can also refer to (autogenerated) :ref:`fulldocs api` for
documentation of all classes and functions in the package.

.. _smol.cofe api:

=========
smol.cofe
=========

This module includes the necessary classes to define, train and test cluster
expansions. A cluster expansion is essentially a way to fit a function of
configurational degrees of freedom using a specific set of basis functions that
allow a sparse representation of that function (which resides in a high
dimensional function space). For a more thorough treatment of the formalism of
cluster expansions refer to this document or any of following references [].

The core classes are:

- :ref:`clustersubspace api`
- :ref:`structurewrangler api`
- :ref:`clusterexpansion api`


.. _clustersubspace api:

ClusterSubspace
---------------

.. autoclass:: smol.cofe.ClusterSubspace
   :members:
   :undoc-members:
   :show-inheritance:

.. autoclass:: smol.cofe.PottsSubspace
   :members:
   :undoc-members:
   :show-inheritance:


.. _structurewrangler api:

StructureWrangler
-----------------

.. autoclass:: smol.cofe.StructureWrangler
   :members:
   :undoc-members:
   :show-inheritance:


.. _clusterexpansion api:

ClusterExpansion
----------------

.. autoclass:: smol.cofe.ClusterExpansion
   :members:
   :undoc-members:
   :show-inheritance:

.. _smol.moca api:

=========
smol.moca
=========

This module includes classes and functions to run Markov Chain Monte Carlo
sampling of statistical mechanical ensembles represented by a cluster expansion
Hamiltonian (there is also support to run MCMC with simple pair interaction
models, such as Ewald electrostatic interactions). MCMC sampling is done for a
specific supercell size. In theory the larger the supercell the better the
results, however in practice there are many other nuances for picking the right
supercell size that are beyond the scope of this documentation. Refer to the
following references for appropriate expositions of the method [].

The core classes are:

- :ref:`ensembles api`

  - :class:`CanonicalEnsemle`
  - :class:`SemiGrandEnsemble`

- :ref:`processors api`

  - :class:`CEProcessor`
  - :class:`EwaldProcessor`
  - :class:`CompositeProcessor`

- :ref:`sampler api`
- :ref:`samplecontainer api`

.. _ensembles api:

Ensembles
---------
:class:`Ensemble` classes represent the specific statistical mechanics ensemble
by defining the relevant thermodynamic boundary conditions in order to compute
the appropriate ensemble probability ratios. Ensembles also hold information
of the underlying set of :class:`Sublattice` for the configuration space to be
sampled. Note that in as implemened an ensemble applies to any temperature,
the specific temperature to generate samples at, is set in a :class:`Sampler`.

.. autoclass:: smol.moca.ensemble.base.Ensemble
   :members:
   :undoc-members:
   :show-inheritance:

.. autoclass:: smol.moca.CanonicalEnsemble
   :members:
   :undoc-members:
   :show-inheritance:

.. autoclass:: smol.moca.SemiGrandEnsemble
   :members:
   :undoc-members:
   :show-inheritance:

.. _processors api:

Processors
----------
A :class:`Processor` is used to optimally compute correlation vectors, energy,
and differences in these from variations in site occupancies. Processors
compute values only for a specific supercell specified by a given supercell
matrix.

Users will rarely need to directly instantiate a processor, it is recommended
to simply create an ensemble using the :meth:`from_cluster_expansion` which
will automatically instantiate the appropriate processor. The accessing the
processor can be done simply by the corresponding attribute (i.e.
:code:`ensemble.processor`). Many methods and attributes of a processor are
very useful for seting up and analysing MCMC sampling runs.

.. autoclass:: smol.moca.processor.base.Processor
   :members:
   :undoc-members:
   :show-inheritance:

.. autoclass:: smol.moca.CEProcessor
   :members:
   :undoc-members:
   :show-inheritance:

.. autoclass:: smol.moca.EwaldProcessor
   :members:
   :undoc-members:
   :show-inheritance:

.. autoclass:: smol.moca.CompositeProcessor
   :members:
   :undoc-members:
   :show-inheritance:

.. _sampler api:

Sampler
-------
A :class:`Sampler` takes care of running MCMC sampling for a given ensemble.
The easiest way to create a sampler (which suffices for most use cases) is to
use the :meth:`from_ensemble` class method. For more advanced use cases and
elaborate MCMC sampling more knowledge of the underlying classes is necessary.

.. autoclass:: smol.moca.Sampler
   :members:
   :undoc-members:
   :show-inheritance:

.. _samplecontainer api:

SampleContainer
---------------

.. autoclass:: smol.moca.SampleContainer
   :members:
   :undoc-members:
   :show-inheritance:


.. _fulldocs api:

Full API Documentation
----------------------
Here is the autogenerated documentation for all of the **smol** source code.
If you find typos, grammar mistakes or confusing sentences please let
*lbluque* know or make a quick PR fixing the docstrings directly in the source
code.

* :ref:`modindex`
* :ref:`genindex`
* :ref:`search`
