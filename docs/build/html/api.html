<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API &#8212; smol 1.0.0 documentation</title>
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/_static/default.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          smol</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="examples.html">Examples</a></li>
                <li><a href="#">API</a></li>
                <li><a href="https://github.com/CederGroupHub/smol">GitHub</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">API</a></li>
<li><a class="reference internal" href="#smol-cofe">smol.cofe</a><ul>
<li><a class="reference internal" href="#clustersubspace">ClusterSubspace</a></li>
<li><a class="reference internal" href="#structurewrangler">StructureWrangler</a></li>
<li><a class="reference internal" href="#clusterexpansion">ClusterExpansion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#smol-moca">smol.moca</a><ul>
<li><a class="reference internal" href="#ensembles">Ensembles</a></li>
<li><a class="reference internal" href="#processors">Processors</a></li>
<li><a class="reference internal" href="#sampler">Sampler</a></li>
<li><a class="reference internal" href="#samplecontainer">SampleContainer</a></li>
<li><a class="reference internal" href="#full-api-documentation">Full API Documentation</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<p><strong>smol</strong> is organized into two main submodules:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#smol-cofe"><span class="std std-ref">smol.cofe</span></a> (Cluster Orbit Fourier Expansion) includes classes and
functions to define, train and test cluster expansions.</p></li>
<li><p><a class="reference internal" href="#smol-moca"><span class="std std-ref">smol.moca</span></a> (Monte Carlo) includes classes and functions to run MCMC
sampling based on a cluster expansion hamiltonian (and a few other
hamiltonian models).</p></li>
</ul>
<p>Below is the documentation for the core classes in each submodule.
You can also refer to (autogenerated) <a class="reference internal" href="#fulldocs"><span class="std std-ref">Full API Documentation</span></a> for
documentation of all classes and functions in the package.</p>
</div>
<div class="section" id="smol-cofe">
<span id="id1"></span><h1>smol.cofe<a class="headerlink" href="#smol-cofe" title="Permalink to this headline">¶</a></h1>
<p>This module includes the necessary classes to define, train and test cluster
expansions. A cluster expansion is essentially a way to fit a function of
configurational degrees of freedom using a specific set of basis functions that
allow a sparse representation of that function (which resides in a high
dimensional function space). For a more thorough treatment of the formalism of
cluster expansions refer to this document or any of following references [].</p>
<p>The core classes are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#clustersubspace"><span class="std std-ref">ClusterSubspace</span></a></p></li>
<li><p><a class="reference internal" href="#structurewrangler"><span class="std std-ref">StructureWrangler</span></a></p></li>
<li><p><a class="reference internal" href="#clusterexpansion"><span class="std std-ref">ClusterExpansion</span></a></p></li>
</ul>
<div class="section" id="clustersubspace">
<span id="id2"></span><h2>ClusterSubspace<a class="headerlink" href="#clustersubspace" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="smol.cofe.ClusterSubspace">
<em class="property">class </em><code class="sig-name descname">ClusterSubspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">expansion_structure</span></em>, <em class="sig-param"><span class="n">symops</span></em>, <em class="sig-param"><span class="n">orbits</span></em>, <em class="sig-param"><span class="n">supercell_matcher</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_matcher</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">matcher_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>ClusterSubspace represents a subspace of functions of configuration.</p>
<p>A <a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterSubspace</span></code></a> is the main work horse used in constructing a
cluster expansion. It is necessary to define the terms to be included in a
cluster expansion. A cluster subspace holds a finite set of orbits that
contain symmetrically equivalent clusters. The orbits also contain the set
of orbit basis functions (also known as correlation functions) that
represent the terms in the cluster expansion. Taken together the set of all
orbit functions for all orbits included span a subspace of the total
function space over the configurational space of a given crystal structure
system.</p>
<p>The <a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterSubspace</span></code></a> also has methods to match fitting structures
and determine site mappings for supercells of different sizes in order to
compute correlation vectors (i.e. evaluate the orbit functions for a given
structure).</p>
<p>Holds a structure, its expansion structure and a list of Orbits.
This class defines the cluster subspace over which to fit a cluster
expansion: This sets the orbits (groups of clusters) and the site basis
functions that are to be considered in the fit.</p>
<p>You probably want to generate from <code class="code docutils literal notranslate"><span class="pre">ClusterSubspace.from_cutoffs</span></code>,
which will auto-generate the orbits from diameter cutoffs.</p>
<dl class="py attribute">
<dt id="smol.cofe.ClusterSubspace.symops">
<code class="sig-name descname">symops</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.symops" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetry operations of structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of SymmOp</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.cofe.ClusterSubspace.num_corr_functions">
<code class="sig-name descname">num_corr_functions</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.num_corr_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of correlation functions (orbit basis functions)
included in the subspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.cofe.ClusterSubspace.num_orbits">
<code class="sig-name descname">num_orbits</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.num_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of crystallographic orbits included in the subspace.
This includes the empty orbit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.cofe.ClusterSubspace.num_clusters">
<code class="sig-name descname">num_clusters</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.num_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of clusters in the primitive cell that are included
in the subspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<p>Initialize a ClusterSubspace.</p>
<p>You rarely will need to create a ClusterSubspace using the main
constructor.
Look at the class method <code class="code docutils literal notranslate"><span class="pre">from_cutoffs</span></code> for the “better” way to
do instantiate a ClusterSubspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – Structure to define the cluster space. Typically the primitive
cell. Includes all species regardless of partial occupation.</p></li>
<li><p><strong>expansion_structure</strong> (<em>Structure</em>) – Structure including only sites that will be included in the
Cluster space. (only those with partial occupancy)</p></li>
<li><p><strong>symops</strong> (<em>list of Symmop</em>) – list of Symmops for the given structure.</p></li>
<li><p><strong>orbits</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – {size: list of Orbits}
Dictionary with size (number of sites) as keys and list of
Orbits as values.</p></li>
<li><p><strong>supercell_matcher</strong> (<em>StructureMatcher</em>) – (optional)
A StructureMatcher class to be used to find supercell matrices
relating the prim structure to other structures. If you pass
this directly you should know how to set the matcher up, other
wise matching your relaxed structures can fail, alot.</p></li>
<li><p><strong>site_matcher</strong> (<em>StructureMatcher</em>) – (optional)
A StructureMatcher class to be used to find site mappings
relating the sites of a given structure to an appropriate
supercell of the prim structure . If you pass this directly you
should know how to set the matcher up other wise matching your
relaxed structures can fail, alot.</p></li>
<li><p><strong>matcher_kwargs</strong> – ltol, stol, angle_tol, supercell_size: parameters to pass
through to the StructureMatchers. Structures that don’t match
to the primitive cell under these tolerances won’t be included
in the expansion. Easiest option for supercell_size is usually
to use a species that has a constant amount per formula unit.
See pymatgen documentation of <code class="xref py py-class docutils literal notranslate"><span class="pre">StructureMatcher</span></code> for
more details.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.add_external_term">
<code class="sig-name descname">add_external_term</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">term</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.add_external_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an external term to subspace.</p>
<p>Add an external term (e.g. an Ewald term) to the cluster expansion
terms. External term classes must be MSONable and implement a method
to obtain a “correlation” see smol.cofe.extern for examples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>term</strong> (<em>ExternalTerm</em>) – An instance of an external term. Currently only EwaldTerm is
implemented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.basis_orthogonal">
<em class="property">property </em><code class="sig-name descname">basis_orthogonal</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.basis_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the orbit basis defined is orthogonal.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.basis_orthonormal">
<em class="property">property </em><code class="sig-name descname">basis_orthonormal</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.basis_orthonormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the orbit basis is orthonormal.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.change_site_bases">
<code class="sig-name descname">change_site_bases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_basis</span></em>, <em class="sig-param"><span class="n">orthonormal</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.change_site_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the type of site basis used in the site basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_basis</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – name of new basis for all site bases</p></li>
<li><p><strong>orthonormal</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – option to orthonormalize all new site basis sets</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Deep copy of instance.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.corr_from_structure">
<code class="sig-name descname">corr_from_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">scmatrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_mapping</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.corr_from_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get correlation vector for structure.</p>
<p>Returns the correlation vector for a given structure. To do this the
correct supercell matrix of the prim needs to be found to then
determine the mappings between sites to create the occupancy
string and also determine the orbit mappings to evaluate the
corresponding cluster functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – structure to compute correlation from</p></li>
<li><p><strong>normalized</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – return the correlation vector normalized by the prim cell size.
In theory correlation vectors are always normalized, but
getting them without normalization allows to compute the
“extensive” values.</p></li>
<li><p><strong>scmatrix</strong> (<em>ndarray</em>) – optional
supercell matrix relating the prim structure to the given
structure. Passing this if it has already been matched will
make things much quicker. You are responsible that it is
correct.</p></li>
<li><p><strong>site_mapping</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – optional
Site mapping as obtained by
<code class="code docutils literal notranslate"><span class="pre">StructureMatcher.get_mapping</span></code>
such that the elements of site_mapping represent the indices
of the matching sites to the prim structure. If you pass this
option you are fully responsible that the mappings are correct!</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>correlation vector for given structure</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.corr_function_multiplicities">
<em class="property">property </em><code class="sig-name descname">corr_function_multiplicities</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.corr_function_multiplicities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of multiplicity of each distinct correlation function.</p>
<p>The length of the list returned is the total number of correlation
functions in the subspace for all orbits. The multiplicity of a
correlation function is the number of symmetrically equivalent bit
orderings the result in the product of the same single site functions.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.expansion_structure">
<em class="property">property </em><code class="sig-name descname">expansion_structure</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.expansion_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the primitive expansion structure (excludes inactive sites).</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.external_terms">
<em class="property">property </em><code class="sig-name descname">external_terms</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.external_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Get external terms to be fitted together with the correlations.</p>
<p>External terms are those represented by pair interaction Hamiltonians
(i.e. Ewald electrostatics)</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.from_cutoffs">
<em class="property">classmethod </em><code class="sig-name descname">from_cutoffs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">cutoffs</span></em>, <em class="sig-param"><span class="n">basis</span><span class="o">=</span><span class="default_value">'indicator'</span></em>, <em class="sig-param"><span class="n">orthonormal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_concentration</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">supercell_matcher</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_matcher</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">matcher_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.from_cutoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a ClusterSubspace from diameter cutoffs.</p>
<p>Creates a <a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterSubspace</span></code></a> with orbits of the given size and
diameter smaller than or equal to the given value. The diameter of an
orbit is the maximum distance between any two sites of a cluster of
that orbit.</p>
<p>The diameter of a cluster is the maximum distance between any two
sites in the cluster.</p>
<p>This is the best (and the only easy) way to create a
<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterSubspace</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – Disordered structure to build a cluster expansion for.
Typically the primitive cell</p></li>
<li><p><strong>cutoffs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – dict of {cluster_size: diameter cutoff}. Cutoffs should be
strictly decreasing. Typically something like {2:5, 3:4}.
Empty and singlet orbits are always included.
To obtain a subspace with only an empty and singlet terms use
an empty dict {}</p></li>
<li><p><strong>basis</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – A string specifying the site basis functions</p></li>
<li><p><strong>orthonormal</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to enforce an orthonormal basis. From the current
available bases only the indicator basis is not orthogonal out
of the box</p></li>
<li><p><strong>use_concentration</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – If true the concentrations in the prim structure sites will be
used to orthormalize site bases. This gives gives a cluster
subspace centered about the prim composition.</p></li>
<li><p><strong>supercell_matcher</strong> (<em>StructureMatcher</em>) – (optional)
A StructureMatcher class to be used to find supercell matrices
relating the prim structure to other structures. If you pass
this directly you should know how to set the matcher up other
wise matching your relaxed structures will fail, alot.</p></li>
<li><p><strong>site_matcher</strong> (<em>StructureMatcher</em>) – (optional)
A StructureMatcher class to be used to find site mappings
relating the sites of a given structure to an appropriate
supercell of the prim structure . If you pass this directly you
should know how to set the matcher up other wise matching your
relaxed structures will fail, alot.</p></li>
<li><p><strong>matcher_kwargs</strong> – ltol, stol, angle_tol, supercell_size. Parameters to pass
through to the StructureMatchers. Structures that don’t match
to the primitive cell under these tolerances won’t be included
in the expansion. Easiest option for supercell_size is usually
to use a species that has a constant amount per formula unit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ClusterSubSpace</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ClusterSubspace from an MSONable dict.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.function_orbit_ids">
<em class="property">property </em><code class="sig-name descname">function_orbit_ids</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.function_orbit_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Orbit IDs corresponding to each correlation function.</p>
<p>If the Cluster Subspace includes external terms these are not included
in the list since they are not associated with any orbit.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.iterorbits">
<code class="sig-name descname">iterorbits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.iterorbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield orbits.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.ncorr_functions_per_orbit">
<em class="property">property </em><code class="sig-name descname">ncorr_functions_per_orbit</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.ncorr_functions_per_orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of correlation functions for each orbit.</p>
<p>The list returned is of length total number of orbits, each entry is
the total number of correlation functions assocaited with that orbit.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.num_prims_from_matrix">
<em class="property">static </em><code class="sig-name descname">num_prims_from_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scmatrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.num_prims_from_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get number of prim structures in a supercell for a given matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.occupancy_from_structure">
<code class="sig-name descname">occupancy_from_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">scmatrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">encode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.occupancy_from_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Occupancy string for a given structure.</p>
<p>Returns a list of occupancies of each site in a the structure in the
appropriate order set implicitly by the supercell matrix that is found.</p>
<p>This function is used as input to compute correlation vectors for the
given structure.</p>
<p>This function is also useful to obtain an initial occupancy for a Monte
Carlo simulation (make sure that the same supercell matrix is being
used here as in the instance of the processor class for the simulation.
Although it is recommended to use the similar function in Processor
classes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – structure to obtain a occupancy string for</p></li>
<li><p><strong>scmatrix</strong> (<em>array</em>) – optional
Super cell matrix relating the given structure and the
primitive structure. I you pass the supercell you fully are
responsible that it is the correct one! This prevents running
the _scmatcher (supercell structure matcher)</p></li>
<li><p><strong>site_mapping</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – optional
Site mapping as obtained by StructureMatcher.get_mapping
such that the elements of site_mapping represent the indices
of the matching sites to the prim structure. I you pass this
option you are fully responsible that the mappings are correct!
This prevents running _site_matcher to get the mappings.</p></li>
<li><p><strong>encode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
If true the occupancy string will have the index of the species
in the expansion structure site spaces, rather than the
species itself.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>occupancy string for structure.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.orbit_multiplicities">
<em class="property">property </em><code class="sig-name descname">orbit_multiplicities</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.orbit_multiplicities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the crystallographic multiplicities for each orbit.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.orbits">
<em class="property">property </em><code class="sig-name descname">orbits</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all orbits sorted by size.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.orbits_by_size">
<em class="property">property </em><code class="sig-name descname">orbits_by_size</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.orbits_by_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dictionary of orbits with key being the orbit size.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.refine_structure">
<code class="sig-name descname">refine_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">scmatrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_mapping</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.refine_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine a (relaxed) structure.</p>
<p>Refine a (relaxed) structure to a perfect supercell structure of the
the prim structure (aka the corresponding “unrelaxed” structure).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – structure to refine to a perfect multiple of the prim</p></li>
<li><p><strong>scmatrix</strong> (<em>ndarray</em>) – optional
supercell matrix relating the prim structure to the given
structure. Passing this if it has already been matched will
make things much quicker. You are responsible for correctness.</p></li>
<li><p><strong>site_mapping</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – optional
Site mapping as obtained by StructureMatcher.get_mapping
such that the elements of site_mapping represent the indices
of the matching sites to the prim structure. Again you are
responsible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The refined structure</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Structure</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.remove_orbit_bit_combos">
<code class="sig-name descname">remove_orbit_bit_combos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orbit_bit_ids</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.remove_orbit_bit_combos" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove orbit bit combos by their ids.</p>
<p>Removes a specific bit combo from an orbit. This allows more granular
removal of terms involved in fitting/evaluating a cluster expansion.
Similar to remove_orbits this is useful to prune a cluster expansion
and actually allows to remove a single term (ie one with small
associated coefficient/ECI).</p>
<p>This procedure is perfectly well posed mathematically. The resultant
CE is still a valid function of configurations with all the necessary
symmetries from the underlying structure. Chemically however it is not
obvious what it means to remove certain combinations of an n-body
interaction term, and not the whole term itself. It would be justified
if we allow “in group” orbit eci sparsity…which everyone in the field
does anyway…</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>orbit_bit_ids</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – list of orbit bit ids to remove</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.remove_orbits">
<code class="sig-name descname">remove_orbits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orbit_ids</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.remove_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove whole orbits by their ids.</p>
<p>Removes orbits from cluster spaces. It is helpful to print a
ClusterSubspace or ClusterExpansion to obtain orbit ids. After removing
orbits, orbit id and orbit bit id are re-assigned.</p>
<p>This is useful to prune a ClusterExpansion by removing orbits with
small associated coefficients or ECI. Note that this will remove a full
orbit, which for the case of sites with only two species is the same as
removing a single correlation vector element (only one ECI). For cases
with sites having more than 2 species allowed per site there are more
than one orbit functions (for all the possible bit orderings) and
removing an orbit will remove more than one element in the correlation
vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>orbit_ids</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – list of orbit ids to be removed</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.scmatrix_from_structure">
<code class="sig-name descname">scmatrix_from_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.scmatrix_from_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get supercell matrix from a given structure.</p>
<p>Obtain the supercell structure matrix to convert the prim structure
to a supercell equivalent to given structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>structure</strong> (<em>Structure</em>) – A pymatgen Structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matrix relating given structure and prim structure.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.structure">
<em class="property">property </em><code class="sig-name descname">structure</code><a class="headerlink" href="#smol.cofe.ClusterSubspace.structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the underlying primitive structure including inactive sites.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.structure_site_mapping">
<code class="sig-name descname">structure_site_mapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">supercell</span></em>, <em class="sig-param"><span class="n">structure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.structure_site_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Get structure site mapping.</p>
<p>Returns the mapping between sites in the given structure and a prim
supercell of the corresponding size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>supercell</strong> (<em>Structure</em>) – Supercell of prim structure with same size as other structure.</p></li>
<li><p><strong>structure</strong> (<em>Structure</em>) – Structure to obtain site mappings to supercell of prim</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>site mappings of structure to supercell</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterSubspace.supercell_orbit_mappings">
<code class="sig-name descname">supercell_orbit_mappings</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scmatrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterSubspace.supercell_orbit_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get orbit mappings for a structure from supercell of prim.</p>
<p>Return the orbit mappings for a specific supercell of the prim
structure represented by the given matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scmatrix</strong> (<em>array</em>) – array relating a supercell with the primitive matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(orbit, indices) list of tuples with orbits and the
site indices for all equivalent orbits in a supercell obtained
from the given matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of tuples</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="structurewrangler">
<span id="id3"></span><h2>StructureWrangler<a class="headerlink" href="#structurewrangler" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="smol.cofe.StructureWrangler">
<em class="property">class </em><code class="sig-name descname">StructureWrangler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_subspace</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>Class to create fitting data to fit a cluster expansion.</p>
<p>A StructureWrangler handles (wrangles) input data structures and properties
to fit in a cluster expansion. This class holds a ClusterSubspace used to
compute correlation vectors and produce feature/design matrices used to fit
the final ClusterExpansion.</p>
<p>This class is meant to take all input training data in the form of
(structure, properties) where the properties represent the target
material property for the given structure that will be used to train
the cluster expansion.</p>
<p>The class takes care of returning the fitting data as a cluster
correlation feature matrix (orbit basis function values). Weights for each
structure can also be provided see the above functions to weight by energy
above hull or energy above composition.</p>
<p>This class also has methods to check/prepare/filter the data. A metadata
dictionary is used to keep track of applied filters, but users can also use
it to save any other pertinent information that will be saved with using
<code class="code docutils literal notranslate"><span class="pre">StructureWrangler.as_dict</span></code> for future reference.</p>
<p>Initialize a StructureWrangler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cluster_subspace</strong> (<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><em>ClusterSubspace</em></a>) – A ClusterSubspace object that will be used to fit a
ClusterExpansion with the provided data.</p>
</dd>
</dl>
<dl class="py method">
<dt id="smol.cofe.StructureWrangler.add_data">
<code class="sig-name descname">add_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">properties</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">supercell_matrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">raise_failed</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a structure and measured property to the StructureWrangler.</p>
<p>The properties are usually extensive (i.e. not normalized per atom
or unit cell, directly from DFT). If the properties have already been
normalized then set normalized to True. Users need to make sure their
normalization is consistent. (Default normalization is per the
primititive structure of the given cluster subspace)</p>
<p>An attempt to computes correlation vector is made and if successful the
structure is succesfully added otherwise it ignores that structure.
Usually failures are caused by the Structure Matcher in the given
ClusterSubspace failing to match structures to the primitive structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – A fit structure</p></li>
<li><p><strong>properties</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – A dictionary with a key describing the property and the target
value for the corresponding structure. For example if only a
single property {‘energy’: value} but can also add more than
one i.e. {‘total_energy’: value1, ‘formation_energy’: value2}.
You are free to make up the keys for each property but make
sure you are consistent for all structures that you add.</p></li>
<li><p><strong>normalized</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Wether the given properties have already been normalized.</p></li>
<li><p><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – The weight given to the structure when doing the fit. The key
must match at least one of the given properties.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – if True then print structures that fail in StructureMatcher.</p></li>
<li><p><strong>supercell_matrix</strong> (<em>ndarray</em>) – optional
If the corresponding structure has already been matched to the
clustersubspace prim structure, passing the supercell_matrix
will use that instead of trying to re-match. If using this
the user is responsible to have the correct supercell_matrix,
Here you are the cause of your own bugs.</p></li>
<li><p><strong>site_mapping</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – optional
Site mapping as obtained by StructureMatcher.get_mapping
such that the elements of site_mapping represent the indices
of the matching sites to the prim structure. I you pass this
option you are fully responsible that the mappings are correct!</p></li>
<li><p><strong>raise_failed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
If true will raise the thrown error when adding a structure
fails. This can be helpful to keep a list of structures that
fail for further inspection.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.add_properties">
<code class="sig-name descname">add_properties</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">property_vector</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.add_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Add another property vector to structures already in the wrangler.</p>
<p>The length of the property vector must match the number of structures
contained, and should be in the same order such that the property
corresponds to the correct structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – Name of property</p></li>
<li><p><strong>property_vector</strong> (<em>ndarray</em>) – Array with the property for each structure</p></li>
<li><p><strong>normalized</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – (optional)
Wether the given properties have already been normalized.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.add_weights">
<code class="sig-name descname">add_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">weights</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.add_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Add weights to structures already in the wrangler.</p>
<p>The length of the given weights must match the number of structures
contained, and should be in the same order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – Name describing weights</p></li>
<li><p><strong>weights</strong> (<em>ndarray</em>) – Array with the weight for each structure</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.append_data_items">
<code class="sig-name descname">append_data_items</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_items</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.append_data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a list of data items.</p>
<p>Each data item must have all necessary fields. A data item can be
obtained using the process_structure method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_items</strong> (<em>list of dict</em>) – list of data items with all necessary information</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.available_properties">
<em class="property">property </em><code class="sig-name descname">available_properties</code><a class="headerlink" href="#smol.cofe.StructureWrangler.available_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of properties that have been added.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.available_weights">
<em class="property">property </em><code class="sig-name descname">available_weights</code><a class="headerlink" href="#smol.cofe.StructureWrangler.available_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of weights that have been added.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.change_subspace">
<code class="sig-name descname">change_subspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_subspace</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.change_subspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the underlying cluster subspace.</p>
<p>Will swap out the cluster subspace and update features accordingly.
This is a faster operation than creating a new one. Can also be useful
to create a copy and the change the subspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cluster_subspace</strong> – New subspace to be used for determining features.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.cluster_subspace">
<em class="property">property </em><code class="sig-name descname">cluster_subspace</code><a class="headerlink" href="#smol.cofe.StructureWrangler.cluster_subspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the underlying ClusterSubspace used to compute features.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.data_items">
<em class="property">property </em><code class="sig-name descname">data_items</code><a class="headerlink" href="#smol.cofe.StructureWrangler.data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of the data item dictionaries.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.feature_matrix">
<em class="property">property </em><code class="sig-name descname">feature_matrix</code><a class="headerlink" href="#smol.cofe.StructureWrangler.feature_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get feature matrix.</p>
<p>Rows are structures, Columns are correlations.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.filter_by_ewald">
<code class="sig-name descname">filter_by_ewald</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_ewald</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.filter_by_ewald" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter structures by electrostatic interaction energy.</p>
<p>Filter the input structures to only use those with low electrostatic
energies (no large charge separation in cell). This energy is
referenced to the lowest value at that composition. Note that this is
before the division by the relative dielectric constant and is per
primitive cell in the cluster expansion – 1.5 eV/atom seems to be a
reasonable value for dielectric constants around 10.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_ewald</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Ewald threshold. The maximum Ewald energy, normalized by prim</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Structure Wrangler from an MSONable dict.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.get_condition_number">
<code class="sig-name descname">get_condition_number</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.get_condition_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the condition number for the feature matrix or submatrix.</p>
<p>The condition number is a measure of how sensitive the solution to
the linear system is to perturbations in the sampled data. The larger
the condition number the more ill-conditioned the linear problem is.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rows</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – indices of structures to include in feature matrix.</p></li>
<li><p><strong>cols</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – indices of features (correlations) to include in feature matrix</p></li>
<li><p><strong>p</strong> – (optional)
the type of norm to use when computing condition number.
see the numpy docs for np.linalg.cond for options.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matrix condition number</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.get_matrix_rank">
<code class="sig-name descname">get_matrix_rank</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.get_matrix_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rank of the feature matrix or a submatrix of it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rows</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – indices of structures to include in feature matrix.</p></li>
<li><p><strong>cols</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – indices of features (correlations) to include in feature matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the rank of the matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.get_property_vector">
<code class="sig-name descname">get_property_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.get_property_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the property target vector.</p>
<p>The property targent vector that be used to fit the corresponding
correlation feature matrix to obtain coefficients for a cluster
expansion. It should always be properly/consistently normalized when
used for a fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – Name of the property</p></li>
<li><p><strong>normalize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
To normalize by prim size. If the property sought is not
already normalized, you need to normalize before fitting a CE.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.get_weights">
<code class="sig-name descname">get_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the weights specified by the given key.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – Name of corresponding weights</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.metadata">
<em class="property">property </em><code class="sig-name descname">metadata</code><a class="headerlink" href="#smol.cofe.StructureWrangler.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dictionary to save applied filters, etc.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.num_features">
<em class="property">property </em><code class="sig-name descname">num_features</code><a class="headerlink" href="#smol.cofe.StructureWrangler.num_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Get umber of features for each added structure.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.num_structures">
<em class="property">property </em><code class="sig-name descname">num_structures</code><a class="headerlink" href="#smol.cofe.StructureWrangler.num_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Get number of structures added (correctly matched to prim).</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.occupancy_strings">
<em class="property">property </em><code class="sig-name descname">occupancy_strings</code><a class="headerlink" href="#smol.cofe.StructureWrangler.occupancy_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get occupancy strings for each of the structures in the wrangler.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.process_structure">
<code class="sig-name descname">process_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">properties</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">supercell_matrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">raise_failed</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.process_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a structure to be added to wrangler.</p>
<p>Checks if the structure for this data item can be matched to the
cluster subspace prim structure to obtain its supercell matrix,
correlation, and refined structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – A structure corresponding to the given properties</p></li>
<li><p><strong>properties</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – A dictionary with a key describing the property and the target
value for the corresponding structure. For example if only a
single property {‘energy’: value} but can also add more than
one i.e. {‘total_energy’: value1, ‘formation_energy’: value2}.
You are free to make up the keys for each property but make
sure you are consistent for all structures that you add.</p></li>
<li><p><strong>normalized</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Wether the given properties have already been normalized.</p></li>
<li><p><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – The weight given to the structure when doing the fit. The key
must match at least one of the given properties.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – if True then print structures that fail in StructureMatcher.</p></li>
<li><p><strong>supercell_matrix</strong> (<em>ndarray</em>) – optional
If the corresponding structure has already been matched to the
clustersubspace prim structure, passing the supercell_matrix
will use that instead of trying to re-match. If using this
the user is responsible to have the correct supercell_matrix,
Here you are the cause of your own bugs.</p></li>
<li><p><strong>site_mapping</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – optional
Site mapping as obtained by
<code class="code docutils literal notranslate"><span class="pre">StructureMatcher.get_mapping</span></code>
such that the elements of site_mapping represent the indices
of the matching sites to the prim structure. If you pass this
option you are fully responsible that the mappings are correct!</p></li>
<li><p><strong>raise_failed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
If true will raise the thrown error when adding a structure
fails. This can be helpful to keep a list of structures that
fail for further inspection.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>data item dict for structure</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.refined_structures">
<em class="property">property </em><code class="sig-name descname">refined_structures</code><a class="headerlink" href="#smol.cofe.StructureWrangler.refined_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of refined structures.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.remove_all_data">
<code class="sig-name descname">remove_all_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.remove_all_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all data from Wrangler.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.remove_properties">
<code class="sig-name descname">remove_properties</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">property_keys</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.remove_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove properties from given keys.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*property_keys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – names of properties to remove</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.remove_structure">
<code class="sig-name descname">remove_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.remove_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a given structure and associated data.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.sizes">
<em class="property">property </em><code class="sig-name descname">sizes</code><a class="headerlink" href="#smol.cofe.StructureWrangler.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get sizes of each structure in terms of number of prims.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.structure_site_mappings">
<em class="property">property </em><code class="sig-name descname">structure_site_mappings</code><a class="headerlink" href="#smol.cofe.StructureWrangler.structure_site_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of site mappings for each structure to prim.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.structures">
<em class="property">property </em><code class="sig-name descname">structures</code><a class="headerlink" href="#smol.cofe.StructureWrangler.structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of included structures.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.supercell_matrices">
<em class="property">property </em><code class="sig-name descname">supercell_matrices</code><a class="headerlink" href="#smol.cofe.StructureWrangler.supercell_matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of supercell matrices relating each structure to prim.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.StructureWrangler.update_features">
<code class="sig-name descname">update_features</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.StructureWrangler.update_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the features/feature matrix for the data held.</p>
<p>This is useful when something is changed in the cluster_subspace after
creating the Wrangler, for example added an Ewald term after creating
the Wrangler. This will prevent having to match structures and such.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="clusterexpansion">
<span id="id4"></span><h2>ClusterExpansion<a class="headerlink" href="#clusterexpansion" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="smol.cofe.ClusterExpansion">
<em class="property">class </em><code class="sig-name descname">ClusterExpansion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_subspace</span></em>, <em class="sig-param"><span class="n">coefficients</span></em>, <em class="sig-param"><span class="n">feature_matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterExpansion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>Class for the ClusterExpansion proper.</p>
<p>This needs a <a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterSubspace</span></code></a> and a corresponding set of
coefficients from a fit.</p>
<p>The main method to use this the predict method to predict the fitted
property for new structures. This can be used to compare the accuracy
of the fit with a set of test structures not used in training.</p>
<p>Although this is purely optional and does not change the class performance,
it is also recommended you save some information about learn metrics
such as CV score, test/train rmse, or anything to quantify the “goodness”
in the metadata dictionary. See for example learn metrics in
<code class="code docutils literal notranslate"><span class="pre">sklearn.metrics</span></code> for many useful methods to get this quantities.</p>
<p>This class is also used for Monte Carlo simulations to create a
<code class="xref py py-class docutils literal notranslate"><span class="pre">CEProcessor</span></code> that calculates the CE for a fixed supercell size.
Before using a ClusterExpansion for Monte Carlo you should consider pruning
the correlation/orbit functions with small coefficients or eci.</p>
<dl class="py attribute">
<dt id="smol.cofe.ClusterExpansion.coefficients">
<code class="sig-name descname">coefficients</code><a class="headerlink" href="#smol.cofe.ClusterExpansion.coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>coefficients of the cluster expansion</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarry</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.cofe.ClusterExpansion.metadata">
<code class="sig-name descname">metadata</code><a class="headerlink" href="#smol.cofe.ClusterExpansion.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>dict to save optional values describing cluster
expansion. i.e. if it was pruned, any error metrics etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a></p>
</dd>
</dl>
</dd></dl>

<p>Initialize a ClusterExpansion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_subspace</strong> (<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><em>ClusterSubspace</em></a>) – A clustersubspace representing the subspace over which the
Cluster Expansion was fit. Must be the same used to create
the feature matrix.</p></li>
<li><p><strong>coefficients</strong> (<em>ndarray</em>) – coefficients for cluster expansion. Make sure the supplied
coefficients to the correlation vector terms (length and order)
These correspond to the
ECI x the multiplicity of orbit x multiplicity of bit ordering</p></li>
<li><p><strong>feature_matrix</strong> (<em>ndarray</em>) – the feature matrix used in fitting the given coefficients.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterExpansion.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.cluster_subspace">
<em class="property">property </em><code class="sig-name descname">cluster_subspace</code><a class="headerlink" href="#smol.cofe.ClusterExpansion.cluster_subspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Get cluster subspace.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.convert_eci">
<code class="sig-name descname">convert_eci</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_basis</span></em>, <em class="sig-param"><span class="n">fit_structures</span></em>, <em class="sig-param"><span class="n">supercell_matrices</span></em>, <em class="sig-param"><span class="n">orthonormal</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterExpansion.convert_eci" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically convert given eci to eci in a new basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_basis</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – name of basis to convert coefficients into.</p></li>
<li><p><strong>fit_structures</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – list of pymatgen.Structure used to fit the eci</p></li>
<li><p><strong>supercell_matrices</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – list of supercell matrices for the corresponding fit structures</p></li>
<li><p><strong>orthonormal</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – option to make new basis orthonormal</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>coefficients converted into new_basis</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.eci">
<em class="property">property </em><code class="sig-name descname">eci</code><a class="headerlink" href="#smol.cofe.ClusterExpansion.eci" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the eci for the cluster expansion.</p>
<p>This just divides by the corresponding multiplicities. External terms
will are dropped since their fitted coefficients do not represent ECI.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.eci_orbit_ids">
<em class="property">property </em><code class="sig-name descname">eci_orbit_ids</code><a class="headerlink" href="#smol.cofe.ClusterExpansion.eci_orbit_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Orbit ids corresponding to each ECI in the Cluster Expansion.</p>
<p>If the Cluster Expansion includes external terms these are not included
in the list since they are not associated with any orbit.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.expansion_structure">
<em class="property">property </em><code class="sig-name descname">expansion_structure</code><a class="headerlink" href="#smol.cofe.ClusterExpansion.expansion_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get expansion structure.</p>
<p>Prim structure with only sites included in the expansion.
(i.e. sites with partial occupancies)</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterExpansion.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ClusterExpansion from serialized MSONable dict.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterExpansion.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the fitted property for a given set of structures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>Structure</em>) – Structures to predict from</p></li>
<li><p><strong>normalize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – Whether to return the predicted property normalized by
the prim cell size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.prim_structure">
<em class="property">property </em><code class="sig-name descname">prim_structure</code><a class="headerlink" href="#smol.cofe.ClusterExpansion.prim_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get primitive structure which the expansion is based on.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.cofe.ClusterExpansion.prune">
<code class="sig-name descname">prune</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">with_multiplicity</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.cofe.ClusterExpansion.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove fit coefficients or ECI’s with small values.</p>
<p>Removes ECI’s and and orbits in the ClusterSubspaces that have
ECI/parameter values smaller than the given threshold.</p>
<p>This will change the fits error metrics (ie RMSE) a little, but it
should not be much. If they change a lot then the threshold used is
probably too high and important functions are being pruned.</p>
<p>This will not re-fit the ClusterExpansion. Note that if you re-fit
after pruning the ECI will probably change and hence also the fit
performance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – threshold below which to remove.</p></li>
<li><p><strong>with_multiplicity</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – if true threshold is applied to the ECI proper, otherwise to
the fit coefficients</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="smol-moca">
<span id="id5"></span><h1>smol.moca<a class="headerlink" href="#smol-moca" title="Permalink to this headline">¶</a></h1>
<p>This module includes classes and functions to run Markov Chain Monte Carlo
sampling of statistical mechanical ensembles represented by a cluster expansion
Hamiltonian (there is also support to run MCMC with simple pair interaction
models, such as Ewald electrostatic interactions). MCMC sampling is done for a
specific supercell size. In theory the larger the supercell the better the
results, however in practice there are many other nuances for picking the right
supercell size that are beyond the scope of this documentation. Refer to the
following references for appropriate expositions of the method [].</p>
<p>The core classes are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ensembles"><span class="std std-ref">Ensembles</span></a></p>
<ul>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CanonicalEnsemle</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MuSemiGrandEnsemble</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FuSemiGrandEnsemble</span></code></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#processors"><span class="std std-ref">Processors</span></a></p>
<ul>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CEProcessor</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">EwaldProcessor</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeProcessor</span></code></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#sampler"><span class="std std-ref">Sampler</span></a></p></li>
<li><p><a class="reference internal" href="#samplecontainer"><span class="std std-ref">SampleContainer</span></a></p></li>
</ul>
<div class="section" id="ensembles">
<span id="id6"></span><h2>Ensembles<a class="headerlink" href="#ensembles" title="Permalink to this headline">¶</a></h2>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Ensemble</span></code> classes represent the specific statistical mechanics ensemble
by defining the relevant thermodynamic boundary conditions in order to compute
the appropriate ensemble probability ratios. Ensembles also hold information
of the underlying set of <code class="xref py py-class docutils literal notranslate"><span class="pre">Sublattice</span></code> for the configuration space to be
sampled. Note that in as implemened an ensemble applies to any temperature,
the specific temperature to generate samples at, is set in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Sampler</span></code>.</p>
<dl class="py class">
<dt id="smol.moca.ensemble.base.Ensemble">
<em class="property">class </em><code class="sig-name descname">Ensemble</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">processor</span></em>, <em class="sig-param"><span class="n">sublattices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/abc.html#abc.ABC" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></a></p>
<p>Abstract Base Class for Monte Carlo Ensembles.</p>
<dl class="py attribute">
<dt id="smol.moca.ensemble.base.Ensemble.num_energy_coefs">
<code class="sig-name descname">num_energy_coefs</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.num_energy_coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of coefficients in the natural parameters array that
correspond to energy only.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.ensemble.base.Ensemble.thermo_boundaries">
<code class="sig-name descname">thermo_boundaries</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.thermo_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary with corresponding thermodynamic boundaries, i.e.
chemical potentials or fugacity fractions. This is kept only for
descriptive purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.ensemble.base.Ensemble.valid_mcmc_steps">
<code class="sig-name descname">valid_mcmc_steps</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.valid_mcmc_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>list of the valid MCMC steps that can be used to sample the
ensemble in MCMC.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<p>Initialize class instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><em>Processor</em></a>) – A processor that can compute the change in a property given
a set of flips.</p></li>
<li><p><strong>sublattices</strong> (<em>list of Sublattice</em>) – optional
list of Lattice objects representing sites in the processor
supercell with same site spaces.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.compute_feature_vector">
<em class="property">abstract </em><code class="sig-name descname">compute_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.compute_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the feature vector for a give occupancy.</p>
<p>The feature vector is the necessary features required to compute
the exponent determining in the relative probability for the given
occupancy (i.e. a generalized enthalpy). The feature vector for
ensembles represents the sufficient statistics.</p>
<p>For a cluster expansion the feature vector is the
correlation vector x system size</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.compute_feature_vector_change">
<em class="property">abstract </em><code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the change in the feature vector from a given step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string.</p></li>
<li><p><strong>step</strong> (<em>list of tuple</em>) – A sequence of flips given my the MCMCUsher.propose_step</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>difference in feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.from_cluster_expansion">
<em class="property">classmethod </em><code class="sig-name descname">from_cluster_expansion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_expansion</span></em>, <em class="sig-param"><span class="n">supercell_matrix</span></em>, <em class="sig-param"><span class="n">optimize_indicator</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.from_cluster_expansion" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an ensemble from a cluster expansion.</p>
<p>Convenience constructor to instantiate an ensemble. This will take
care of initializing the correct processor based on the
ClusterExpansion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_expansion</strong> (<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterExpansion" title="smol.cofe.ClusterExpansion"><em>ClusterExpansion</em></a>) – A cluster expansion object.</p></li>
<li><p><strong>supercell_matrix</strong> (<em>ndarray</em>) – Supercell matrix defining the system size.</p></li>
<li><p><strong>optimize_indicator</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
Wether to optimize calculations for indicator basis.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to pass to ensemble constructor. Such as
sublattices, sublattice_probabilities, chemical_potentials,
fugacity_fractions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Ensemble</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.natural_parameters">
<em class="property">abstract property </em><code class="sig-name descname">natural_parameters</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.natural_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the vector of natural parameters.</p>
<p>The natural parameters correspond to the fit coeficients of the
underlying processor plus any additional terms involved in the Legendre
transformation corresponding to the ensemble.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.num_sites">
<em class="property">property </em><code class="sig-name descname">num_sites</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.num_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total number of sites in the supercell.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.processor">
<em class="property">property </em><code class="sig-name descname">processor</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the ensemble processor.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.reset_restricted_sites">
<code class="sig-name descname">reset_restricted_sites</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.reset_restricted_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Unfreeze all previously restricted sites.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.restrict_sites">
<code class="sig-name descname">restrict_sites</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sites</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.restrict_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Restricts (freezes) the given sites.</p>
<p>This will exclude those sites from being flipped during a Monte Carlo
run. If some of the given indices refer to inactive sites, there will
be no effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sites</strong> (<em>Sequence</em>) – indices of sites in the occupancy string to restrict.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.restricted_sites">
<em class="property">property </em><code class="sig-name descname">restricted_sites</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.restricted_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Get indices of all restricted sites.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.sublattices">
<em class="property">property </em><code class="sig-name descname">sublattices</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.sublattices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get names of sublattices.</p>
<p>Useful if allowing flips only from certain sublattices is needed.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.base.Ensemble.system_size">
<em class="property">property </em><code class="sig-name descname">system_size</code><a class="headerlink" href="#smol.moca.ensemble.base.Ensemble.system_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get size of supercell in number of prims.</p>
</dd></dl>

<dl class="py attribute">
<dt id="id0">
<code class="sig-name descname">valid_mcmc_steps</code><em class="property"> = None</em><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="smol.moca.CanonicalEnsemble">
<em class="property">class </em><code class="sig-name descname">CanonicalEnsemble</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">processor</span></em>, <em class="sig-param"><span class="n">sublattices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CanonicalEnsemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.base.Ensemble" title="smol.moca.ensemble.base.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">smol.moca.ensemble.base.Ensemble</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>Canonical Ensemble class to run Monte Carlo Simulations.</p>
<p>Initialize CanonicalEnemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><em>Processor</em></a>) – A processor that can compute the change in a property given
a set of flips.</p></li>
<li><p><strong>sublattices</strong> (<em>list of Sublattice</em>) – optional
list of Lattice objects representing sites in the processor
supercell with same site spaces.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.CanonicalEnsemble.compute_feature_vector">
<code class="sig-name descname">compute_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CanonicalEnsemble.compute_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the feature vector for a given occupancy.</p>
<p>In the canonical case it is just the feature vector from the underlying
processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CanonicalEnsemble.compute_feature_vector_change">
<code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CanonicalEnsemble.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the change in the feature vector from a given step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string.</p></li>
<li><p><strong>step</strong> (<em>list of tuple</em>) – A sequence of flips as given my the MCMCUsher.propose_step</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>difference in feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CanonicalEnsemble.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CanonicalEnsemble.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a CanonicalEnsemble from dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – dictionary representation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>CanonicalEnsemble</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CanonicalEnsemble.natural_parameters">
<em class="property">property </em><code class="sig-name descname">natural_parameters</code><a class="headerlink" href="#smol.moca.CanonicalEnsemble.natural_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the vector of exponential parameters.</p>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.CanonicalEnsemble.valid_mcmc_steps">
<code class="sig-name descname">valid_mcmc_steps</code><em class="property"> = ('swap',)</em><a class="headerlink" href="#smol.moca.CanonicalEnsemble.valid_mcmc_steps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble">
<em class="property">class </em><code class="sig-name descname">BaseSemiGrandEnsemble</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">processor</span></em>, <em class="sig-param"><span class="n">sublattices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.base.Ensemble" title="smol.moca.ensemble.base.Ensemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">smol.moca.ensemble.base.Ensemble</span></code></a></p>
<p>Abstract Semi-Grand Canonical Base Ensemble.</p>
<p>Total number of species are fixed but composition of “active” (with partial
occupancies) sublattices is allowed to change.</p>
<p>This class can not be instantiated. See <a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.semigrand.MuSemiGrandEnsemble" title="smol.moca.ensemble.semigrand.MuSemiGrandEnsemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">MuSemiGrandEnsemble</span></code></a> and
<a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.semigrand.FuSemiGrandEnsemble" title="smol.moca.ensemble.semigrand.FuSemiGrandEnsemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">FuSemiGrandEnsemble</span></code></a> below.</p>
<p>Initialize BaseSemiGrandEnsemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><em>Processor</em></a>) – A processor that can compute the change in a property given
a set of flips. See moca.processor</p></li>
<li><p><strong>sublattices</strong> (<em>list of Sublattice</em>) – optional
list of Lattice objects representing sites in the processor
supercell with same site spaces.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.compute_chemical_work">
<em class="property">abstract </em><code class="sig-name descname">compute_chemical_work</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.compute_chemical_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the chemical work term.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.compute_feature_vector">
<code class="sig-name descname">compute_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.compute_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the feature vector for a given occupancy.</p>
<p>In the semigrand case it is the feature vector and the chemical work
term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.natural_parameters">
<em class="property">property </em><code class="sig-name descname">natural_parameters</code><a class="headerlink" href="#smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.natural_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the vector of natural parameters.</p>
<p>For SGC an extra -1 is added for the chemical part of the LT.</p>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.valid_mcmc_steps">
<code class="sig-name descname">valid_mcmc_steps</code><em class="property"> = ('flip',)</em><a class="headerlink" href="#smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble.valid_mcmc_steps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="smol.moca.MuSemiGrandEnsemble">
<em class="property">class </em><code class="sig-name descname">MuSemiGrandEnsemble</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">processor</span></em>, <em class="sig-param"><span class="n">chemical_potentials</span></em>, <em class="sig-param"><span class="n">sublattices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.MuSemiGrandEnsemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble" title="smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>Relative chemical potential based SemiGrand Ensemble.</p>
<p>A Semi-Grand Canonical Ensemble for Monte Carlo Simulations where species
relative chemical potentials are predefined. Note that in the SGC Ensemble
implemented here, only the differences in chemical potentials with
respect to a reference species on each sublattice are fixed, and not the
absolute values. To obtain the absolute values you must calculate the
reference chemical potential and then simply subtract it from the given
values.</p>
<dl class="py attribute">
<dt id="smol.moca.MuSemiGrandEnsemble.thermo_boundaries">
<code class="sig-name descname">thermo_boundaries</code><a class="headerlink" href="#smol.moca.MuSemiGrandEnsemble.thermo_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>dict of chemical potentials.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a></p>
</dd>
</dl>
</dd></dl>

<p>Initialize MuSemiGrandEnsemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><em>Processor</em></a>) – A processor that can compute the change in a property given
a set of flips.</p></li>
<li><p><strong>chemical_potentials</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – Dictionary with species and chemical potentials.</p></li>
<li><p><strong>sublattices</strong> (<em>list of Sublattice</em>) – optional
List of Sublattice objects representing sites in the processor
supercell with same site spaces.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.MuSemiGrandEnsemble.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.MuSemiGrandEnsemble.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.MuSemiGrandEnsemble.chemical_potentials">
<em class="property">property </em><code class="sig-name descname">chemical_potentials</code><a class="headerlink" href="#smol.moca.MuSemiGrandEnsemble.chemical_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the chemical potentials for species in system.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.MuSemiGrandEnsemble.compute_chemical_work">
<code class="sig-name descname">compute_chemical_work</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.MuSemiGrandEnsemble.compute_chemical_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sum of mu * N for given occupancy.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.MuSemiGrandEnsemble.compute_feature_vector_change">
<code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.MuSemiGrandEnsemble.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the change in the feature vector from a given step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string.</p></li>
<li><p><strong>step</strong> (<em>list of tuple</em>) – A sequence of flips given my the MCMCUsher.propose_step</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>difference in feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.MuSemiGrandEnsemble.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.MuSemiGrandEnsemble.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a MuSemiGrandEnsemble from dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>CanonicalEnsemble</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="smol.moca.FuSemiGrandEnsemble">
<em class="property">class </em><code class="sig-name descname">FuSemiGrandEnsemble</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">processor</span></em>, <em class="sig-param"><span class="n">fugacity_fractions</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sublattices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.FuSemiGrandEnsemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble" title="smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">smol.moca.ensemble.semigrand.BaseSemiGrandEnsemble</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>Fugacity fraction SemiGrandEnsemble.</p>
<p>A Semi-Grand Canonical Ensemble for Monte Carlo simulations where the
species fugacity ratios are set constant. This implicitly sets the chemical
potentials, albeit for a specific temperature. Since one species per
sublattice is the reference species, to calculate actual fugacities the
reference fugacity must be computed as an ensemble average and all other
fugacities can then be calculated. From the fugacities and the set
temperature the corresponding chemical potentials can then be calculated.</p>
<dl class="py attribute">
<dt id="smol.moca.FuSemiGrandEnsemble.thermo_boundaries">
<code class="sig-name descname">thermo_boundaries</code><a class="headerlink" href="#smol.moca.FuSemiGrandEnsemble.thermo_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary of fugacity fractions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a></p>
</dd>
</dl>
</dd></dl>

<p>Initialize MuSemiGrandEnsemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><em>Processor</em></a>) – A processor that can compute the change in a property given
a set of flips. See moca.processor</p></li>
<li><p><strong>fugacity_fractions</strong> (<em>sequence of dicts</em>) – optional
Dictionary of species name and fugacity fraction for each
sublattice (.i.e think of it as the sublattice concentrations
for random structure). If not given this will be taken from the
prim structure used in the cluster subspace. Needs to be in
the same order as the corresponding sublattice.</p></li>
<li><p><strong>sublattices</strong> (<em>list of Sublattice</em>) – optional
list of Sublattice objects representing sites in the processor
supercell with same site spaces.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.FuSemiGrandEnsemble.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.FuSemiGrandEnsemble.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.FuSemiGrandEnsemble.compute_chemical_work">
<code class="sig-name descname">compute_chemical_work</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.FuSemiGrandEnsemble.compute_chemical_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute log of product of fugacities for given occupancy.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.FuSemiGrandEnsemble.compute_feature_vector_change">
<code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.FuSemiGrandEnsemble.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the change in the feature vector from a given step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string.</p></li>
<li><p><strong>step</strong> (<em>list of tuple</em>) – A sequence of flips given my the MCMCUsher.propose_step</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>difference in feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.FuSemiGrandEnsemble.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.FuSemiGrandEnsemble.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a FuSemiGrandEnsemble from dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>FuSemiGrandEnsemble</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.FuSemiGrandEnsemble.fugacity_fractions">
<em class="property">property </em><code class="sig-name descname">fugacity_fractions</code><a class="headerlink" href="#smol.moca.FuSemiGrandEnsemble.fugacity_fractions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the fugacity fractions for species in system.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="processors">
<span id="id7"></span><h2>Processors<a class="headerlink" href="#processors" title="Permalink to this headline">¶</a></h2>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Processor</span></code> is used to optimally compute correlation vectors, energy,
and differences in these from variations in site occupancies. Processors
compute values only for a specific supercell specified by a given supercell
matrix.</p>
<p>Users will rarely need to directly instantiate a processor, it is recommended
to simply create an ensemble using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_cluster_expansion()</span></code> which
will automatically instantiate the appropriate processor. The accessing the
processor can be done simply by the corresponding attribute (i.e.
<code class="code docutils literal notranslate"><span class="pre">ensemble.processor</span></code>). Many methods and attributes of a processor are
very useful for seting up and analysing MCMC sampling runs.</p>
<dl class="py class">
<dt id="smol.moca.processor.base.Processor">
<em class="property">class </em><code class="sig-name descname">Processor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_subspace</span></em>, <em class="sig-param"><span class="n">supercell_matrix</span></em>, <em class="sig-param"><span class="n">coefficients</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>Abstract base class for processors.</p>
<p>A processor is used to provide a quick way to calculated energy differences
(probability ratio’s) between two configurational states for a fixed system
size/supercell.</p>
<dl class="py attribute">
<dt id="smol.moca.processor.base.Processor.unique_site_spaces">
<code class="sig-name descname">unique_site_spaces</code><a class="headerlink" href="#smol.moca.processor.base.Processor.unique_site_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of all the distinct site spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)">tuple</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.processor.base.Processor.allowed_species">
<code class="sig-name descname">allowed_species</code><a class="headerlink" href="#smol.moca.processor.base.Processor.allowed_species" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of tuples of the allowed species at each site.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.processor.base.Processor.size">
<code class="sig-name descname">size</code><a class="headerlink" href="#smol.moca.processor.base.Processor.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of prims in the supercell structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<p>Initialize a BaseProcessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_subspace</strong> (<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><em>ClusterSubspace</em></a>) – A cluster subspace</p></li>
<li><p><strong>supercell_matrix</strong> (<em>ndarray</em>) – An array representing the supercell matrix with respect to the
ClusterExpansion prim structure.</p></li>
<li><p><strong>coefficients</strong> – single or array of fit coefficients.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.processor.base.Processor.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a><a class="headerlink" href="#smol.moca.processor.base.Processor.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.cluster_subspace">
<em class="property">property </em><code class="sig-name descname">cluster_subspace</code><a class="headerlink" href="#smol.moca.processor.base.Processor.cluster_subspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the underlying cluster subspace.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.compute_average_drift">
<code class="sig-name descname">compute_average_drift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterations</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.compute_average_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute average forward and reverse drift for the given property.</p>
<p>This is a sanity check function. The drift value should be very, very,
very small, the smaller the better…think machine precision values.</p>
<p>The average drift is the difference between the quick routine for used
for MC to get a property difference from a single flip and the
change in that property from explicitly calculating it fully for the
initial state and the flipped state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iterations</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
number of iterations/flips to compute.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(float, float) forward and reverse average property drift</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)">tuple</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.compute_feature_vector">
<em class="property">abstract </em><code class="sig-name descname">compute_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.compute_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the feature vector for a given occupancy array.</p>
<p>Each entry in the correlation vector corresponds to a particular
symmetrically distinct bit ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupation array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>correlation vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.compute_feature_vector_change">
<em class="property">abstract </em><code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">flips</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the change in the feature vector from a list of flips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p></li>
<li><p><strong>flips</strong> (<em>list of tuple</em>) – list of tuples with two elements. Each tuple represents a
single flip where the first element is the index of the site
in the occupancy array and the second element is the index
for the new species to place at that site.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>change in correlation vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.compute_property">
<code class="sig-name descname">compute_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.compute_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the property for the given occupancy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>predicted property</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.compute_property_change">
<code class="sig-name descname">compute_property_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">flips</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.compute_property_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute change in property from a set of flips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p></li>
<li><p><strong>flips</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – list of tuples for (index of site, specie code to set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>property difference between inital and final states</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.decode_occupancy">
<code class="sig-name descname">decode_occupancy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">encoded_occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.decode_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an encoded occupancy string of int to species str.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.encode_occupancy">
<code class="sig-name descname">encode_occupancy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.encode_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode occupancy string of species str to ints.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a processor from serialized MSONable dict.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.num_sites">
<em class="property">property </em><code class="sig-name descname">num_sites</code><a class="headerlink" href="#smol.moca.processor.base.Processor.num_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Get total number of sites in supercell.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.occupancy_from_structure">
<code class="sig-name descname">occupancy_from_structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.occupancy_from_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the occupancy array for a given structure.</p>
<p>The structure must strictly be a supercell of the prim according to the
processor’s supercell matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>structure</strong> (<em>Structure</em>) – A pymatgen structure (related to the cluster-expansion prim
by the supercell matrix passed to the processor)</p>
</dd>
</dl>
<dl class="simple">
<dt>Returns: encoded occupancy string</dt><dd><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.structure">
<em class="property">property </em><code class="sig-name descname">structure</code><a class="headerlink" href="#smol.moca.processor.base.Processor.structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the underlying supercell disordered structure.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.structure_from_occupancy">
<code class="sig-name descname">structure_from_occupancy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.processor.base.Processor.structure_from_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Structure from an occupancy string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Structure</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.processor.base.Processor.supercell_matrix">
<em class="property">property </em><code class="sig-name descname">supercell_matrix</code><a class="headerlink" href="#smol.moca.processor.base.Processor.supercell_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the give supercell matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="smol.moca.CEProcessor">
<em class="property">class </em><code class="sig-name descname">CEProcessor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_subspace</span></em>, <em class="sig-param"><span class="n">supercell_matrix</span></em>, <em class="sig-param"><span class="n">coefficients</span></em>, <em class="sig-param"><span class="n">optimize_indicator</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CEProcessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">smol.moca.processor.base.Processor</span></code></a></p>
<p>CEProcessor class to use a ClusterExpansion in MC simulations.</p>
<p>A CE processor is optimized to compute correlation vectors and local
changes in correlation vectors. This class allows the use a cluster
expansion Hamiltonian to run Monte Carlo based simulations.</p>
<p>A processor allows an ensemble class to generate a Markov chain
for sampling thermodynamic properties from a cluster expansion
Hamiltonian.</p>
<dl class="py attribute">
<dt id="smol.moca.CEProcessor.optimize_indicator">
<code class="sig-name descname">optimize_indicator</code><a class="headerlink" href="#smol.moca.CEProcessor.optimize_indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>If true the local correlation update function specialized for
indicator bases is used. This should only be used when the
expansion was fit with an indicator basis and no additional
normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.CEProcessor.coefs">
<code class="sig-name descname">coefs</code><a class="headerlink" href="#smol.moca.CEProcessor.coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Fitted coefficients from the cluster expansion.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.CEProcessor.n_orbit_functions">
<code class="sig-name descname">n_orbit_functions</code><a class="headerlink" href="#smol.moca.CEProcessor.n_orbit_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of orbit basis functions (correlation functions).
This includes all possible labellings/orderings for all orbits.
Same as <code class="code docutils literal notranslate"><span class="pre">ClusterSubspace.n_bit_orderings</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<p>Initialize a CEProcessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_subspace</strong> (<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><em>ClusterSubspace</em></a>) – A cluster subspace</p></li>
<li><p><strong>supercell_matrix</strong> (<em>ndarray</em>) – An array representing the supercell matrix with respect to the
Cluster Expansion prim structure.</p></li>
<li><p><strong>coefficients</strong> (<em>ndarray</em>) – Fit coefficients for the represented cluster expansion.</p></li>
<li><p><strong>optimize_indicator</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – When using an indicator basis, sets the function to compute
correlation differences to the indicator optimized function.
This can make MC steps faster.
Make sure your cluster expansion was indeed fit with an
indicator basis set, otherwise your MC results are no good.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.CEProcessor.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a><a class="headerlink" href="#smol.moca.CEProcessor.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CEProcessor.compute_feature_vector">
<code class="sig-name descname">compute_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CEProcessor.compute_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the correlation vector for a given occupancy string.</p>
<p>The correlation vector in this case is normalized per supercell. In
other works it is extensive corresponding to the size of the supercell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupation array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>correlation vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CEProcessor.compute_feature_vector_change">
<code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">flips</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CEProcessor.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the change in the correlation vector from a list of flips.</p>
<p>The correlation vector in this case is normalized per supercell. In
other works it is extensive corresponding to the size of the supercell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string</p></li>
<li><p><strong>flips</strong> (<em>list of tuple</em>) – list of tuples with two elements. Each tuple represents a
single flip where the first element is the index of the site
in the occupancy string and the second element is the index
for the new species to place at that site.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>change in correlation vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CEProcessor.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CEProcessor.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a CEProcessor from serialized MSONable dict.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="smol.moca.EwaldProcessor">
<em class="property">class </em><code class="sig-name descname">EwaldProcessor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_subspace</span></em>, <em class="sig-param"><span class="n">supercell_matrix</span></em>, <em class="sig-param"><span class="n">ewald_term</span></em>, <em class="sig-param"><span class="n">coefficient</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">ewald_summation</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.EwaldProcessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">smol.moca.processor.base.Processor</span></code></a></p>
<p>Processor for CE’s including an EwaldTerm.</p>
<p>A Processor class that handles changes for the electrostatic interaction
energy using an Ewald Summation term.</p>
<p>Initialize an EwaldCEProcessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_subspace</strong> (<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><em>ClusterSubspace</em></a>) – A cluster subspace.</p></li>
<li><p><strong>supercell_matrix</strong> (<em>ndarray</em>) – An array representing the supercell matrix with respect to the
Cluster Expansion prim structure.</p></li>
<li><p><strong>ewald_term</strong> (<a class="reference internal" href="smol.cofe.extern.html#smol.cofe.extern.ewald.EwaldTerm" title="smol.cofe.extern.ewald.EwaldTerm"><em>EwaldTerm</em></a>) – An instance of EwaldTerm to compute electrostatic energies.</p></li>
<li><p><strong>coefficient</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Fitting coeficient to scale Ewald energy by.</p></li>
<li><p><strong>ewald_summation</strong> (<em>EwaldSummation</em>) – optional
pymatgen EwaldSummation instance, make sure this uses the exact
same parameters as those used in the EwaldTerm in the cluster
Expansion (i.e. same eta, real and recip cuts).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.EwaldProcessor.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a><a class="headerlink" href="#smol.moca.EwaldProcessor.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.EwaldProcessor.compute_feature_vector">
<code class="sig-name descname">compute_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.EwaldProcessor.compute_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the feature vector for a given occupancy array.</p>
<p>Each entry in the correlation vector corresponds to a particular
symmetrically distinct bit ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupation array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>correlation vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.EwaldProcessor.compute_feature_vector_change">
<code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">flips</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.EwaldProcessor.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the change in the feature vector from a list of flips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy string</p></li>
<li><p><strong>flips</strong> (<em>list of tuple</em>) – list of tuples with two elements. Each tuple represents a
single flip where the first element is the index of the site
in the occupancy string and the second element is the index
for the new species to place at that site.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>change in correlation vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.EwaldProcessor.compute_property">
<code class="sig-name descname">compute_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.EwaldProcessor.compute_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Ewald electrostatic energy for a given occupancy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Ewald electrostatic energy</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.EwaldProcessor.compute_property_change">
<code class="sig-name descname">compute_property_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">flips</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.EwaldProcessor.compute_property_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute change in electrostatic energy from a set of flips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p></li>
<li><p><strong>flips</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – list of tuples for (index of site, specie code to set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>electrostatic energy change</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.EwaldProcessor.ewald_matrix">
<em class="property">property </em><code class="sig-name descname">ewald_matrix</code><a class="headerlink" href="#smol.moca.EwaldProcessor.ewald_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the electrostatic interaction matrix.</p>
<p>The matrix used is the one set in the EwaldTerm of the given
ClusterExpansion.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.EwaldProcessor.ewald_summation">
<em class="property">property </em><code class="sig-name descname">ewald_summation</code><a class="headerlink" href="#smol.moca.EwaldProcessor.ewald_summation" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the pymatgen EwaldSummation object.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.EwaldProcessor.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.EwaldProcessor.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a CEProcessor from serialized MSONable dict.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="smol.moca.CompositeProcessor">
<em class="property">class </em><code class="sig-name descname">CompositeProcessor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cluster_subspace</span></em>, <em class="sig-param"><span class="n">supercell_matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CompositeProcessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">smol.moca.processor.base.Processor</span></code></a></p>
<p>CompositeProcessor class used for mixed models.</p>
<p>A Composite processor is merely a container for many different processors
that acts as an interface such that it can be used in the same way as an
individual processor. This can be used to mix models in any way that your
heart desires.</p>
<p>The most common use case of them all is a CompositeProcessor of a
CEProcessor and an EwaldProcessor for use in ionic materials.</p>
<p>You can add anyone of the other processor class implemented to build a
composite processor.</p>
<p>It is recommended to use the <code class="code docutils literal notranslate"><span class="pre">from_cluster_expansion</span></code> to create an
ensemble and the underlying processor automatically rather than directly
creating a processor. This will take care of creating the correct
<a class="reference internal" href="smol.moca.html#smol.moca.CompositeProcessor" title="smol.moca.CompositeProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeProcessor</span></code></a> or <a class="reference internal" href="smol.moca.html#smol.moca.CEProcessor" title="smol.moca.CEProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">CEProcessor</span></code></a> for you.</p>
<p>Initialize a CompositeProcessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster_subspace</strong> (<a class="reference internal" href="smol.cofe.html#smol.cofe.ClusterSubspace" title="smol.cofe.ClusterSubspace"><em>ClusterSubspace</em></a>) – A cluster subspace</p></li>
<li><p><strong>supercell_matrix</strong> (<em>ndarray</em>) – An array representing the supercell matrix with respect to the
Cluster Expansion prim structure.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.CompositeProcessor.add_processor">
<code class="sig-name descname">add_processor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">processor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CompositeProcessor.add_processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a processor to composite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>processor</strong> (<a class="reference internal" href="smol.moca.processor.html#smol.moca.processor.base.Processor" title="smol.moca.processor.base.Processor"><em>Processor</em></a>) – Processor to add. Must have the same cluster subspace and
supercell matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CompositeProcessor.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a><a class="headerlink" href="#smol.moca.CompositeProcessor.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CompositeProcessor.compute_feature_vector">
<code class="sig-name descname">compute_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CompositeProcessor.compute_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the feature vector for a given occupancy array.</p>
<p>Each entry in the correlation vector corresponds to a particular
symmetrically distinct bit ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupation array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>correlation vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CompositeProcessor.compute_feature_vector_change">
<code class="sig-name descname">compute_feature_vector_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">flips</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CompositeProcessor.compute_feature_vector_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the change in the feature vector from a list of flips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p></li>
<li><p><strong>flips</strong> (<em>list of tuple</em>) – list of tuples with two elements. Each tuple represents a
single flip where the first element is the index of the site
in the occupancy array and the second element is the index
for the new species to place at that site.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>change in feature vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CompositeProcessor.compute_property">
<code class="sig-name descname">compute_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CompositeProcessor.compute_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the property for the given occupancy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>predicted property</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CompositeProcessor.compute_property_change">
<code class="sig-name descname">compute_property_change</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">occupancy</span></em>, <em class="sig-param"><span class="n">flips</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CompositeProcessor.compute_property_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute change in property from a set of flips.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occupancy</strong> (<em>ndarray</em>) – encoded occupancy array</p></li>
<li><p><strong>flips</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><em>list</em></a>) – list of tuples for (index of site, specie code to set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>property difference between inital and final states</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CompositeProcessor.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.CompositeProcessor.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Composite from serialized MSONable dict.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.CompositeProcessor.processors">
<em class="property">property </em><code class="sig-name descname">processors</code><a class="headerlink" href="#smol.moca.CompositeProcessor.processors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of processor in composite.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sampler">
<span id="id8"></span><h2>Sampler<a class="headerlink" href="#sampler" title="Permalink to this headline">¶</a></h2>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Sampler</span></code> takes care of running MCMC sampling for a given ensemble.
The easiest way to create a sampler (which suffices for most use cases) is to
use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_ensemble()</span></code> class method. For more advanced use cases and
elaborate MCMC sampling more knowledge of the underlying classes is necessary.</p>
<dl class="py class">
<dt id="smol.moca.Sampler">
<em class="property">class </em><code class="sig-name descname">Sampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kernel</span></em>, <em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.Sampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A sampler is used to run MCMC sampling simulations.</p>
<p>The specific MCMC algorithm is defined by the given MCMCKernel.
The default will use a a simple Metropolis random walk kernel.</p>
<p>Initialize BaseSampler.</p>
<p>It is recommended to initialize a sampler with the from_ensemble
method, unless you need more control.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel</strong> (<a class="reference internal" href="smol.moca.sampler.html#smol.moca.sampler.kernel.MCMCKernel" title="smol.moca.sampler.kernel.MCMCKernel"><em>MCMCKernel</em></a>) – An MCMCKernel instance.</p></li>
<li><p><strong>container</strong> (<a class="reference internal" href="smol.moca.html#smol.moca.SampleContainer" title="smol.moca.SampleContainer"><em>SampleContainer</em></a>) – A sampler containter to store samples. If given num_walkers is
taken from the container.</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
seed for random number generator.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.Sampler.anneal">
<code class="sig-name descname">anneal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">temperatures</span></em>, <em class="sig-param"><span class="n">mcmc_steps</span></em>, <em class="sig-param"><span class="n">initial_occupancies</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">progress</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.Sampler.anneal" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a simulated annealing procedure.</p>
<p>Uses the total number of temperatures given by “steps” interpolating
between the start and end temperature according to a cooling function.
The start temperature is the temperature set for the ensemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>temperatures</strong> (<em>Sequence</em>) – Sequence of temperatures to anneal, should be strictly
decreasing.</p></li>
<li><p><strong>mcmc_steps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – number of Monte Carlo steps to run at each temperature.</p></li>
<li><p><strong>initial_occupancies</strong> (<em>ndarray</em>) – array of occupancies. If None, the last sample will be taken.
You should only provide this the first time you call run.</p></li>
<li><p><strong>thin_by</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
the amount to thin by for saving samples.</p></li>
<li><p><strong>progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – If true will show a progress bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.clear_samples">
<code class="sig-name descname">clear_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.Sampler.clear_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear samples from sampler container.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.efficiency">
<code class="sig-name descname">efficiency</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.Sampler.efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the efficiency of MCMC sampling (accepted/total).</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.from_ensemble">
<em class="property">classmethod </em><code class="sig-name descname">from_ensemble</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ensemble</span></em>, <em class="sig-param"><span class="n">temperature</span></em>, <em class="sig-param"><span class="n">step_type</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel_type</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nwalkers</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.Sampler.from_ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sampler based on an Ensemble instances.</p>
<p>This is the easier way to spin up a Sampler. This will
automatically populate and create an appropriate SampleContainer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.base.Ensemble" title="smol.moca.ensemble.base.Ensemble"><em>Ensemble</em></a>) – An Ensemble class to obtain sample probabilities from.</p></li>
<li><p><strong>temperature</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Temperature to run Monte Carlo at.</p></li>
<li><p><strong>step_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – optional
type of step to run MCMC with. If not given the default is the
first entry in the Ensemble.valid_mcmc_steps.</p></li>
<li><p><strong>kernel_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – optional
string specifying the specific MCMC transition kernel. This
represents the underlying MC algorithm. Currently only
Metropolis is supported.</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
Seed for the PRNG.</p></li>
<li><p><strong>nwalkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
Number of walkers/chains to sampler. Default is 1. More than 1
is still experimental…</p></li>
<li><p><strong>*args</strong> – Positional arguments to pass to the MCMCKernel constructor</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments to pass to the MCMCKernel constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sampler</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.mcmckernel">
<em class="property">property </em><code class="sig-name descname">mcmckernel</code><a class="headerlink" href="#smol.moca.Sampler.mcmckernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the underlying ensemble.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">initial_occupancies</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">progress</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">stream_chunk</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">stream_file</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">swmr_mode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.Sampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an MCMC sampling simulation.</p>
<p>This will run and save the samples every thin_by into a
SampleContainer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsteps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – number of total MC steps.</p></li>
<li><p><strong>initial_occupancies</strong> (<em>ndarray</em>) – array of occupancies. If None, the last sampler will be taken.
You should only provide this the first time you call run. If
you want to reset then you should call reset before to start
a fresh run.</p></li>
<li><p><strong>thin_by</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
the amount to thin by for saving samples.</p></li>
<li><p><strong>progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
If true will show a progress bar.</p></li>
<li><p><strong>stream_chunk</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
Chunk of samples to stream into a file. If &gt; 0 samples will
be flushed to backend file in stream_chucks</p></li>
<li><p><strong>stream_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – optional
file name to use as backend. If file already exists will try
to append to datasets. If not given will create a new file.</p></li>
<li><p><strong>swmr_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
If true allows to read file from other processes. Single Writer
Multiple Readers.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsteps</span></em>, <em class="sig-param"><span class="n">initial_occupancies</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">progress</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.Sampler.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate MCMC samples.</p>
<p>Yield a sampler state every <cite>thin_by</cite> iterations. A state is give by
a tuple of (occupancies, features, enthalpy)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsteps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of iterations to run.</p></li>
<li><p><strong>initial_occupancies</strong> (<em>ndarray</em>) – array of occupancies</p></li>
<li><p><strong>thin_by</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
Number to thin iterations by and provide samples.</p></li>
<li><p><strong>progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – If true will show a progress bar.</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>tuple</em> – accepted, occupancies, features change, enthalpies change</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.samples">
<em class="property">property </em><code class="sig-name descname">samples</code><a class="headerlink" href="#smol.moca.Sampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the SampleContainer.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.Sampler.seed">
<em class="property">property </em><code class="sig-name descname">seed</code><a class="headerlink" href="#smol.moca.Sampler.seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Seed for the random number generator.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="samplecontainer">
<span id="id9"></span><h2>SampleContainer<a class="headerlink" href="#samplecontainer" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="smol.moca.SampleContainer">
<em class="property">class </em><code class="sig-name descname">SampleContainer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_sites</span></em>, <em class="sig-param"><span class="n">sublattices</span></em>, <em class="sig-param"><span class="n">natural_parameters</span></em>, <em class="sig-param"><span class="n">num_energy_coefs</span></em>, <em class="sig-param"><span class="n">sampling_metadata</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nwalkers</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>A SampleContainter class stores Monte Carlo simulation samples.</p>
<p>A SampleContainer holds samples and sampling information from an MCMC
sampling run. It is useful to obtain the raw data and minimal empirical
properties of the underlying distribution in order to carry out further
analysis of the MCMC sampling results.</p>
<p>When getting any value from the provided attributes, the highly repeated
args are:</p>
<blockquote>
<div><dl class="simple">
<dt>discard (int): optional</dt><dd><p>Number of samples to discard to obtain the value requested.</p>
</dd>
<dt>thin_by (int): optional</dt><dd><p>Use every thin by sample to obtain the value requested.</p>
</dd>
<dt>flat (bool): optional</dt><dd><p>If more than 1 walkers are used flattening will flatten all
chains into one. Defaults to True.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py attribute">
<dt id="smol.moca.SampleContainer.num_sites">
<code class="sig-name descname">num_sites</code><a class="headerlink" href="#smol.moca.SampleContainer.num_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of system (usually in number of prims in supercell, but
can be anything representative i.e. number of sites)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.SampleContainer.sublattices">
<code class="sig-name descname">sublattices</code><a class="headerlink" href="#smol.moca.SampleContainer.sublattices" title="Permalink to this definition">¶</a></dt>
<dd><p>Sublattices of the ensemble sampled.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of Sublattice</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.SampleContainer.natural_parameters">
<code class="sig-name descname">natural_parameters</code><a class="headerlink" href="#smol.moca.SampleContainer.natural_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>array of natural parameters used in the ensemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.SampleContainer.total_mc_steps">
<code class="sig-name descname">total_mc_steps</code><a class="headerlink" href="#smol.moca.SampleContainer.total_mc_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations used in sampling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.SampleContainer.metadata">
<code class="sig-name descname">metadata</code><a class="headerlink" href="#smol.moca.SampleContainer.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of metadata from the MC run that generated the samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="smol.moca.SampleContainer.aux_checkpoint">
<code class="sig-name descname">aux_checkpoint</code><a class="headerlink" href="#smol.moca.SampleContainer.aux_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Checkpoint dictionary of auxiliary states and variables to continue
sampling from the last state of a previous MCMC run.
(not implemented yet)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)">dict</a></p>
</dd>
</dl>
</dd></dl>

<p>Initialize a sample container.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_sites</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Total number of sites in supercell of the ensemble.</p></li>
<li><p><strong>sublattices</strong> (<em>list of Sublattice</em>) – Sublattices of the ensemble sampled.</p></li>
<li><p><strong>natural_parameters</strong> (<em>ndarray</em>) – array of natural parameters used in the ensemble.</p></li>
<li><p><strong>num_energy_coefs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – the number of coeficients in the natural parameters that
correspond to the energy only.</p></li>
<li><p><strong>sampling_metadata</strong> (<a class="reference internal" href="smol.moca.ensemble.html#smol.moca.ensemble.base.Ensemble" title="smol.moca.ensemble.base.Ensemble"><em>Ensemble</em></a>) – Sampling metadata (i.e. ensemble name, mckernel type, etc)</p></li>
<li><p><strong>nwalkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of walkers used to generate chain. Default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="smol.moca.SampleContainer.allocate">
<code class="sig-name descname">allocate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nsamples</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate more space in arrays for more samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.as_dict">
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Json-serialization dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MSONable dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all samples from container.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.composition_variance">
<code class="sig-name descname">composition_variance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.composition_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variance in composition of all species.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.energy_variance">
<code class="sig-name descname">energy_variance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.energy_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the variance of sampled energies.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.enthalpy_variance">
<code class="sig-name descname">enthalpy_variance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.enthalpy_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variance in enthalpy.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.feature_vector_variance">
<code class="sig-name descname">feature_vector_variance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.feature_vector_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variance of feature vector elements.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.flush_to_backend">
<code class="sig-name descname">flush_to_backend</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">backend</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.flush_to_backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush current samples and trace to backend file.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.from_dict">
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a SampleContainer from dict representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><em>dict</em></a>) – dictionary representation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sublattice</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.from_hdf5">
<em class="property">classmethod </em><code class="sig-name descname">from_hdf5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="n">swmr_mode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.from_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a SampleContainer from an hdf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – path to file</p></li>
<li><p><strong>swmr_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
If true allows to read file from other processes. Single Writer
Multiple Readers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>SampleContainer</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_backend">
<code class="sig-name descname">get_backend</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="n">alloc_nsamples</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">swmr_mode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a backend file object.</p>
<p>Currently only hdf5 files supported</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – path to backend file.</p></li>
<li><p><strong>alloc_nsamples</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – optional
number of new samples to allocate. Will only extend datasets
if number given is larger than space left to write samples
into.</p></li>
<li><p><strong>swmr_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – optional
If true allows to read file from other processes. Single Writer
Multiple Readers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>h5.File object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_compositions">
<code class="sig-name descname">get_compositions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the compositions for each occupancy in the chain.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_energies">
<code class="sig-name descname">get_energies</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_energies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the energies from samples in chain.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_enthalpies">
<code class="sig-name descname">get_enthalpies</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_enthalpies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the generalized entalpy changes from samples in chain.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_feature_vectors">
<code class="sig-name descname">get_feature_vectors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_feature_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the feature vector changes from samples in chain.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_minimum_energy">
<code class="sig-name descname">get_minimum_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_minimum_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum energy from samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_minimum_energy_occupancy">
<code class="sig-name descname">get_minimum_energy_occupancy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_minimum_energy_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the occupancy with minimum energy from samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_minimum_enthalpy">
<code class="sig-name descname">get_minimum_enthalpy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_minimum_enthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum energy from samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_minimum_enthalpy_occupancy">
<code class="sig-name descname">get_minimum_enthalpy_occupancy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_minimum_enthalpy_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the occupancy with minimum energy from samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_occupancies">
<code class="sig-name descname">get_occupancies</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_occupancies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an occupancy chain from samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_species_counts">
<code class="sig-name descname">get_species_counts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_species_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the species counts for each occupancy in the chain.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_sublattice_compositions">
<code class="sig-name descname">get_sublattice_compositions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sublattice</span></em>, <em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_sublattice_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the compositions of a specific sublattice.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_sublattice_species_counts">
<code class="sig-name descname">get_sublattice_species_counts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sublattice</span></em>, <em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_sublattice_species_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the counts of each species in a sublattices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>where last axis is the count for each species in same</dt><dd><p>order as the underlying site space.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.get_temperatures">
<code class="sig-name descname">get_temperatures</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.get_temperatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the generalized entalpy changes from samples in chain.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.mean_composition">
<code class="sig-name descname">mean_composition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.mean_composition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get mean composition for all species regardless of sublattice.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.mean_energy">
<code class="sig-name descname">mean_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mean energy from samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.mean_enthalpy">
<code class="sig-name descname">mean_enthalpy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.mean_enthalpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mean generalized enthalpy.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.mean_feature_vector">
<code class="sig-name descname">mean_feature_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.mean_feature_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mean feature vector from samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.mean_sublattice_composition">
<code class="sig-name descname">mean_sublattice_composition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sublattice</span></em>, <em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.mean_sublattice_composition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mean composition of a specific sublattice.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.num_samples">
<em class="property">property </em><code class="sig-name descname">num_samples</code><a class="headerlink" href="#smol.moca.SampleContainer.num_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total number of samples.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.sampling_efficiency">
<code class="sig-name descname">sampling_efficiency</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.sampling_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sampling efficiency for chains.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.save_sample">
<code class="sig-name descname">save_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">accepted</span></em>, <em class="sig-param"><span class="n">temperature</span></em>, <em class="sig-param"><span class="n">occupancies</span></em>, <em class="sig-param"><span class="n">enthalpy</span></em>, <em class="sig-param"><span class="n">features</span></em>, <em class="sig-param"><span class="n">thinned_by</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.save_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a sample from the generated chain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>accepted</strong> (<em>ndarray</em>) – array of total acceptances.</p></li>
<li><p><strong>temperature</strong> (<em>ndarray</em>) – array of temperatures at which samples were taken.</p></li>
<li><p><strong>occupancies</strong> (<em>ndarray</em>) – array of occupancies</p></li>
<li><p><strong>enthalpy</strong> (<em>ndarray</em>) – array of generalized enthalpy changes</p></li>
<li><p><strong>features</strong> (<em>ndarray</em>) – array of feature vector changes</p></li>
<li><p><strong>thinned_by</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – the amount that the sampling was thinned by. Used to update
the total mc iterations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#smol.moca.SampleContainer.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of the samples in chain.</p>
</dd></dl>

<dl class="py method">
<dt id="smol.moca.SampleContainer.sublattice_composition_variance">
<code class="sig-name descname">sublattice_composition_variance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sublattice</span></em>, <em class="sig-param"><span class="n">discard</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">thin_by</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">flat</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#smol.moca.SampleContainer.sublattice_composition_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the varience in composition of a specific sublattice.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="full-api-documentation">
<span id="fulldocs"></span><h2>Full API Documentation<a class="headerlink" href="#full-api-documentation" title="Permalink to this headline">¶</a></h2>
<p>Here is the autogenerated documentation for all of the <strong>smol</strong> source code.
If you find typos, grammar mistakes or confusing sentences please let
<em>lbluque</em> know or make a quick PR fixing the docstrings directly in the source
code.</p>
<ul class="simple">
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2020, Ceder Group.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>